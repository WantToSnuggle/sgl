## SGL (Small Graphics Library)

### 移植步骤如下：
1. 复制`source`目录下的所有文件到自己的项目中
2. 将`include`目录添加到头文件路径中
3. 仅保留`mm`目录下的`lwmem`目录，其他目录删除掉
4. 将`source`目录添加到头文件路径中
5. 修改`sgl_config.h`文件的内容，以适配自己的硬件，修改如下(仅供参考):
    ```c
    #define  CONFIG_SGL_PANEL_PIXEL_DEPTH                      16   
    #define  CONFIG_SGL_EVENT_QUEUE_SIZE                       16   
    #define  CONFIG_SGL_OBJ_SLOT_DYNAMIC                       1    
    #define  CONFIG_SGL_OBJ_NUM_MAX                            0     
    #define  CONFIG_SGL_COLOR16_SWAP                           0     
    #define  CONFIG_SGL_DEBUG                                  1    
    #define  CONFIG_SGL_LOG_COLOR                              1    
    #define  CONFIG_SGL_LOG_LEVEL                              0    
    #define  CONFIG_SGL_FONT                                   1    
    #define  CONFIG_SGL_TEXT_UTF8                              0     
    #define  CONFIG_SGL_USE_OBJ_ID                             0    
    #define  CONFIG_SGL_USE_STYLE_UNIFIED_API                  1    
    #define  CONFIG_SGL_HEAP_ALGO                              lwmem
    #define  CONFIG_SGL_FL_INDEX_MAX                           0   
    #define  CONFIG_SGL_HEAP_MEMORY_SIZE                       10240
    #define  CONFIG_SGL_FONT_SONG23                            1    
    #define  CONFIG_SGL_FONT_CONSOLAS23                        0    
    #define  CONFIG_SGL_FONT_KAI33                             0
    #define  CONFIG_SGL_THEME_DEFAULT                          1    
    ```
    上面的参数的含义如下：
    - `CONFIG_SGL_PANEL_PIXEL_DEPTH`: 屏幕的像素深度，16位
    - `CONFIG_SGL_EVENT_QUEUE_SIZE`: 事件队列大小，这里设置为16
    - `CONFIG_SGL_OBJ_SLOT_DYNAMIC`: 控件槽动态分配，这里开启
    - `CONFIG_SGL_OBJ_NUM_MAX`: 控件数量最大值，因为使用了`CONFIG_SGL_OBJ_SLOT_DYNAMIC`，这里设置为0
    - `CONFIG_SGL_COLOR16_SWAP`: 颜色16位字节对调，这里设置为0
    - `CONFIG_SGL_DEBUG`: 调试开关，打开
    - `CONFIG_SGL_LOG_COLOR`: 日志颜色开关，打开
    - `CONFIG_SGL_LOG_LEVEL`: 日志等级，设置为0
    - `CONFIG_SGL_FONT`: 是否使用字体，打开
    - `CONFIG_SGL_TEXT_UTF8`: 是否使用UTF-8编码，这里设置为0
    - `CONFIG_SGL_USE_OBJ_ID`: 控件ID开关，关闭
    - `CONFIG_SGL_USE_STYLE_UNIFIED_API`: 控件样式统一接口开关，打开
    - `CONFIG_SGL_HEAP_ALGO`: 内存分配算法，设置为`lwmem`
    - `CONFIG_SGL_FL_INDEX_MAX`: tlsf字体索引最大值，因为使用了`lwmem`，所以这里设置为0
    - `CONFIG_SGL_HEAP_MEMORY_SIZE`： 内存分配算法的堆大小，单位：字节，这里设置为10K
    - `CONFIG_SGL_FONT_SONG23`: 宋体23号字体开关，打开
    - `CONFIG_SGL_FONT_CONSOLAS23`: 思源黑体23号字体开关，关闭
    - `CONFIG_SGL_FONT_KAI33`: 楷体33号字体开关，关闭

然后编译整个项目，看看能否编译通过，如果一切顺利的话，继续下面步骤。

### 注册底层绘图接口（必须）
和大多数GUI库一样，在使用SGL库之前，请注册底层的绘图接口，底层接口的注册如下：
```c

void panel_flush_area(int16_t x, int16_t y, int16_t w, int16_t h, sgl_color_t *src)
{
    tft_set_win(x, y, x + w - 1, y + h - 1);
	GPIO_WriteBit(SPI_DC_PORT, SPI_DC_PIN, 1);
	SPI1_WriteMultByte((uint8_t*)src, w * h * 2);
}

...
sgl_device_fb_t fb_dev = {
    .xres = CONFIG_SGL_PANEL_WIDTH,
    .yres = CONFIG_SGL_PANEL_HEIGHT,
    .xres_virtual = CONFIG_SGL_PANEL_WIDTH,
    .yres_virtual = CONFIG_SGL_PANEL_HEIGHT,
    .flush_area = panel_flush_area,
    .framebuffer = panel_buffer,
    .framebuffer_size = SGL_ARRAY_SIZE(panel_buffer), 
};

sgl_device_fb_register(&fb_dev);
...
```
上面的过程中定义了一个`sgl_device_fb_t`结构体，并且初始化了一些主要的参数，参数的含义如下：
- `xres`: 屏幕的宽度
- `yres`: 屏幕的高度
- `xres_virtual`: 屏幕的虚拟宽度
- `yres_virtual`: 屏幕的虚拟高度
- `flush_area`：刷新区域函数，用于刷新指定区域
- `framebuffer`：帧缓冲区指针，指向帧缓冲区地址处
- `framebuffer_size`：帧缓冲区大小，单位：字节

`sgl_device_fb_register`函数用于注册帧缓冲区设备，参数为`sgl_device_fb_t`结构体指针。

### 注册调试接口（可选）
使用`void sgl_device_log_register(void (*log_puts)(const char *str))`函数来注册调试接口， 参数为一个指向`log_puts`函数的指针，例如下面的代码：
```c
void uart_put_string(const char *str) {
   /* 发送串口数据 */
}

...
sgl_device_log_register(uart_put_string);
...

```

### 调用sgl_init()函数
首先需要先包含`sgl.h`头文件，然后调用`sgl_init()`函数用于初始化`SGL`库，其中包括内存初始化，`SGL`数据结构初始化等，然后即可开始创建控件和绘制图形了，例如下面的代码：
```c
#include <sgl.h>

int main(void)
{
    sgl_device_log_register(uart_put_string);
    sgl_device_fb_register(&fb_dev);

    sgl_init();

    /* 创建控件 */

    while(1) {
        sgl_task_handle();
    };

    return 0;
}
```

### 注册鼠标事件(或者触摸点击事件)
在鼠标点击事件或者触摸点击事件的中断服务函数中调用`sgl_event_send_pos()`函数，这个函数会处理鼠标点击事件或者触摸点击事件，参数为鼠标点击事件坐标和触摸点击事件的类型，例如下面的代码：
```c
/* 包含头文件 */
#include <sgl.h>
...
static void mouse_event_interrupt(xxxxx) 
{
    sgl_event_t evt;

    if(判断按下) {
        evt.pos.x = event->motion.x;
        evt.pos.y = event->motion.y;
        evt.type = SGL_EVENT_PRESSED;
        sgl_event_send_pos(evt.pos, evt.type);
    }
    else if(判断释放) {
        evt.pos.x = event->motion.x;
        evt.pos.y = event->motion.y;
        evt.type = SGL_EVENT_RELEASED;
        sgl_event_send_pos(evt.pos, evt.type);
    }
}
```


### 创建控件
如用如下代码来创建一个控件：
```c
sgl_obj_t *button = sgl_button_create(NULL);
sgl_obj_set_pos(button, 100, 300);
sgl_obj_set_size(button, 200, 100);
sgl_obj_set_font(button, &song23);
sgl_obj_set_radius(button, 60);
sgl_obj_set_border_width(button, 0);
sgl_obj_set_style(button, SGL_STYLE_TEXT_COLOR, 0x5de);
sgl_obj_set_style(button, SGL_STYLE_TEXT ,SGL_TEXT("Click me!"));
```

## DMA支持
`SGL`库支持`DMA`，即使用`DMA`来传输数据，这样能提高效率，但是`DMA`支持需要硬件支持，如果硬件不支持`DMA`，则需要关闭`DMA`支持，在`sgl_config.h`文件中，将`CONFIG_SGL_DRAW_USE_DMA`宏定义为`1`，表示使用`DMA`来传输数据，例如下面的代码：
`sgl_config.h`文件内容如下：   
```c
CONFIG_SGL_PANEL_PIXEL_DEPTH                      16   
CONFIG_SGL_EVENT_QUEUE_SIZE                       16
CONFIG_SGL_DRAW_USE_DMA                           1     //开启DMA支持
CONFIG_SGL_COLOR16_SWAP                           0     
CONFIG_SGL_ANIMATION                              0    
CONFIG_SGL_ANIMATION_TICK_MS                      1    
CONFIG_SGL_DEBUG                                  1    
CONFIG_SGL_LOG_COLOR                              1    
CONFIG_SGL_LOG_LEVEL                              0    
CONFIG_SGL_FONT                                   1    
CONFIG_SGL_TEXT_UTF8                              0     
CONFIG_SGL_USE_OBJ_ID                             1    
CONFIG_SGL_USE_STYLE_UNIFIED_API                  1    
CONFIG_SGL_HEAP_ALGO                              lwmem
CONFIG_SGL_FL_INDEX_MAX                           20   
CONFIG_SGL_HEAP_MEMORY_SIZE                       10240
CONFIG_SGL_FONT_SONG23                            1    
CONFIG_SGL_FONT_CONSOLAS23                        0    
CONFIG_SGL_FONT_KAI33                             0    
```
底层刷图接口：  
```c
...
void panel_flush_area(int16_t x, int16_t y, int16_t w, int16_t h, sgl_color_t *src)
{
    tft_set_win(x, y, x + w - 1, y + h - 1);
	GPIO_WriteBit(SPI_DC_PORT, SPI_DC_PIN, 1);
	SPI1_DMA_WriteMultByte((uint8_t*)src, w * h * 2);
}
...
int main(void)
{
    ...
    sgl_device_fb_t fb_dev = {
        .xres = CONFIG_SGL_PANEL_WIDTH,
        .yres = CONFIG_SGL_PANEL_HEIGHT,
        .xres_virtual = CONFIG_SGL_PANEL_WIDTH,
        .yres_virtual = CONFIG_SGL_PANEL_HEIGHT,
        .flush_area = panel_flush_area,
        .framebuffer = panel_buffer,
        .framebuffer_size = SGL_ARRAY_SIZE(panel_buffer), 
    };

    sgl_device_fb_register(&fb_dev);
    ...
    sgl_init();

    /* 创建控件 */

    while(1) {
        sgl_task_handle();
    };

    return 0;
}

```
当使用`DMA`时，`panel_buffer`的大小必须超过`2`行帧缓冲的大小，这是因为使用`DMA`会自动使用双缓冲。

